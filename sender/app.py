from __future__ import annotations

import base64
import hashlib
import os
from pathlib import Path
from typing import Optional, Literal

import requests
from fastapi import FastAPI, Query
from pydantic import BaseModel

# --- Config ---
DEFAULT_GATEWAY_FORWARD_URL = os.getenv("GATEWAY_FORWARD_URL", "http://127.0.0.1:8000/forward")
KEYS_DIR = Path(__file__).resolve().parent
PRIVATE_KEY_PATH = Path(os.getenv("SENDER_PRIVATE_KEY_PATH", str(KEYS_DIR / "private.pem")))
PUBLIC_KEY_PATH  = Path(os.getenv("SENDER_PUBLIC_KEY_PATH",  str(KEYS_DIR / "public.pem")))


# If you set GENERATE_KEYS=1, sender can generate keys if missing (useful for demos)
GENERATE_KEYS = os.getenv("GENERATE_KEYS", "0") == "1"

app = FastAPI(title="Sender (Hashing + Send to Gateway)")


# -------------------------
# Models
# -------------------------
class SendRequest(BaseModel):
    message: str
    # If you (Person 2) donâ€™t sign, you can paste signature_b64 generated by Person 3 here.
    # If omitted, sender will try to sign using PRIVATE_KEY_PATH.
    signature_b64: Optional[str] = None


class HashDemoRequest(BaseModel):
    message: str
    # change exactly one character to demonstrate avalanche effect
    index: int = 0
    new_char: str = "X"


# -------------------------
# Hashing helpers (Person 2)
# -------------------------
def sha256_hex(message: str) -> str:
    return hashlib.sha256(message.encode("utf-8")).hexdigest()


def mutate_one_char(s: str, index: int, new_char: str) -> str:
    if not s:
        return s
    i = max(0, min(index, len(s) - 1))
    return s[:i] + (new_char[:1] if new_char else "X") + s[i + 1 :]



def load_private_key():
    from cryptography.hazmat.primitives import serialization

    if not PRIVATE_KEY_PATH.exists():
        return None

    data = PRIVATE_KEY_PATH.read_bytes()
    return serialization.load_pem_private_key(data, password=None)


def sign_message_b64(message: str) -> str:
    """
    Signs message bytes using an RSA private key at PRIVATE_KEY_PATH
    using PKCS#1 v1.5 + SHA-256 (matches receiver verification).
    """
    priv = load_private_key()
    if priv is None:
        raise FileNotFoundError(
            f"Private key not found at {PRIVATE_KEY_PATH}. "
            f"Run: py tools\\make_keys.py  (it writes sender/private.pem + receiver/public.pem)"
        )

    from cryptography.hazmat.primitives.asymmetric import rsa, padding
    from cryptography.hazmat.primitives import hashes

    if not isinstance(priv, rsa.RSAPrivateKey):
        raise TypeError(
            f"Expected RSA private key, got {type(priv)}. "
            f"Regenerate keys with tools/make_keys.py"
        )

    msg_bytes = message.encode("utf-8")

    sig = priv.sign(
        msg_bytes,
        padding.PKCS1v15(),
        hashes.SHA256(),
    )

    return base64.b64encode(sig).decode("utf-8")





@app.get("/")
def health():
    return {
        "status": "sender running",
        "gateway_forward_url": DEFAULT_GATEWAY_FORWARD_URL,
        "private_key_path": str(PRIVATE_KEY_PATH),
        "public_key_path": str(PUBLIC_KEY_PATH),
        "generate_keys": GENERATE_KEYS,
        "endpoints": ["/hash_demo", "/send"],
    }


@app.post("/hash_demo")
def hash_demo(req: HashDemoRequest):
    original = req.message
    modified = mutate_one_char(original, req.index, req.new_char)

    return {
        "original_message": original,
        "original_sha256_hex": sha256_hex(original),
        "modified_message": modified,
        "modified_sha256_hex": sha256_hex(modified),
        "explain": "Changing 1 character causes a completely different SHA-256 hash (avalanche effect).",
    }


@app.post("/send")
def send_to_gateway(
    req: SendRequest,
    mode: Literal["pass", "tamper"] = Query("pass"),
    gateway_forward_url: str = Query(DEFAULT_GATEWAY_FORWARD_URL),
):
    # Person 2: always compute and show hash
    hash_hex = sha256_hex(req.message)

    # Signature: either provided (from Person 3) or sign locally if key exists
    signature_b64 = req.signature_b64
    if signature_b64 is None:
        signature_b64 = sign_message_b64(req.message)

    payload = {
        "message": req.message,
        "signature_b64": signature_b64,
    }

    # Send to gateway (gateway will forward to receiver)
    r = requests.post(gateway_forward_url, params={"mode": mode}, json=payload, timeout=10)
    r.raise_for_status()

    return {
        "sender_message": req.message,
        "sender_sha256_hex": hash_hex,
        "signature_b64": signature_b64,
        "gateway_mode": mode,
        "gateway_forward_url": gateway_forward_url,
        "gateway_response": r.json(),
        "explain": "Sender hashes the message (SHA-256). Signature is sent alongside message for receiver verification.",
    }
